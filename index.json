[{"categories":["Outreachy"],"contents":"This is my first blog in the series where I talk about my experience as an intern at Outreachy, and working with the Moja Global community! I\u0026rsquo;m more than excited to share how things go as i move along, and I hope to continue writing these blogs weekly.\nIn this blog, I will be talking about myself and the core values that helped me throughout the journey.\nWho Am I?\nHello :). I am Ankita Sharma, currently pursuing B.Tech in Electronics and Communication from International Institute of Information Technology, Naya Raipur, India. During my initial years of graduation, I realized my interest in Computer Science and development. My motivation to see how real-life development works in an organization led me explore open source development.\nMy Open Source Journey\nHonestly, I was very eager to contribute to open source but sometimes ( almost everytime I would say :( ) it looks really overwhelming. There are lots of open issues and a lot of source code that is hard for me to understand at first. But, I was always interested in working hard to get comfortable and create an impact. Plus the open source community members were always welcoming throughtout the journey which always motivated me to learn and keep contributing, so thanks to them :).\nOutreachy\nI have been accepted as an Outreachy Intern for Moja Global organization for the project \u0026ldquo;Research data sources for carbon sequestration in forests\u0026rdquo; under the guidance of Andrew O\u0026rsquo;Reilly-Nugent and Harsh Bardhan Mishra.\nTalking about my jouney for Outreachy - I came to know about outreachy while searching for open source opportunities. I remember how I eagerly waited for the initial applications to open. While looking at the project lists, I found the moja global organization to be very interesting. Fortunately, my skillset also matched with the project requirements. During my contribution period to Moja Global, I found the community members really helpful and welcoming. After the announcement of outreachy final results, I was on cloud nine :D!. I am really excited to work with Moja Global. Thanks to my mentors - Andrew and Harsh for their guidance throughout the journey :).\nCore values that helped me\nThe will to Never Give Up!. I always believe the most certain way to suceed is always to try one more time :). After getting a few rejections in some internship programmes. I got frustated and thought of giving up but somehow I encouraged myself to try one more time, everytime :)\nAnd yes, I made it! \u0026lt;3. I am here as a Moja Global Intern in Outreachy. :)\nThanks for reading! See you in the next blog \u0026lt;3\n ","permalink":"https://ankitaS11.github.io/posts/2022/06/outreachy-introduce-yourself/","tags":["Outreachy","Moja Global"],"title":"Outreachy | Introduce Yourself"},{"categories":["cpp","leetcode"],"contents":"I came across an interesting question, so thought of sharing this!\nQuestion : Given an array nums of n integers where n \u0026gt; 1, return an array output such that output[i] is equal to the product of all the elements of nums except nums[i].\nExample 1:\nInput: [1,2,3,4]\rOutput: [24,12,8,6]\rExample 2:\nInput: nums = [-1,1,0,-3,3]\rOutput: [0,0,9,0,0]\rConstraints:\n1. 2 \u0026lt;= nums.length \u0026lt;= 105\r2. -30 \u0026lt;= nums[i] \u0026lt;= 30\r3. The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.\rProblem link: Product of Array Except Self\nLets begin with the straight forward approach (i.e. Brute force solution).\nclass Solution { public: vector\u0026lt;int\u0026gt; productExceptSelf(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int product = 1; vector\u0026lt;int\u0026gt; output; for (int i = 0; i \u0026lt; nums.size(); i++) { for (int j = 0; j \u0026lt; nums.size(); j++) { if (i != j) product = product * nums[j]; } output.insert(output.begin() + i, product) } return output; } }; The time complexity for this solution is O(n²) so it\u0026rsquo;s not much efficient. Another idea that\u0026rsquo;s coming in my mind is to obtain product for all the elements in the array and divide by the number that shouldn\u0026rsquo;t be included in the array. Let\u0026rsquo;s try and see what happens.\nclass Solution { public: vector\u0026lt;int\u0026gt; productExceptSelf(vector\u0026lt;int\u0026gt;\u0026amp; nums) { vector\u0026lt;int\u0026gt; output; int product = 1; for (int i = 0; i \u0026lt; nums.size(); i++) { product = product * nums[i]; } for (int i = 0; i \u0026lt; nums.size(); i++) { output.insert(output.begin() + i, product/nums[i]); } return output; } }; This looks good but what if nums[i] = 0? This seems to be an important edge case where division by zero exception will occur. So, to avoid this, we can think of two use cases -\n One 0 exists in the input array. More than one 0 exists in the input array.  For the second case i.e. 0 existing more than once, we can say the output array will all elements equal to zero.\nBut, for the first case i.e. if we have only one 0, then we will only get output for that item only.\nInput: nums = [-1,1,0,-3,3]\rOutput: [0,0,9,0,0]\rThis can be solved easily by using a zero counter and if else condition.\nclass Solution { public: vector\u0026lt;int\u0026gt; productExceptSelf(vector\u0026lt;int\u0026gt;\u0026amp; nums) { vector\u0026lt;int\u0026gt; output; int product = 1, count_zero = 0; for (int i = 0; i \u0026lt; nums.size(); i++) { if (nums[i] == 0) { count_zero++; } else { product *= nums[i]; } } for (int i = 0; i \u0026lt; nums.size(); i++) { // In case one element in the input array is 0.  if (count_zero == 1) { if (nums[i] == 0) output.insert(output.begin() + i, product); else output.insert(output.begin() + i, 0); } // In case more than one element is 0.  else if (count_zero \u0026gt; 1) { output.insert(output.begin() + i, 0); } // In rest of cases, i.e. count_zero = 0.  else { output.insert(output.begin() + i, product/nums[i]); } } return output; } }; Yayy!! The time complexity for this solution is O(n), this is much more efficient than our very first approach.\nAnother way to solve the problem without divison is to observe the pattern, maintain a left multiplication array and store right multiplication value.\nInput: [1,2,3,4]\rOutput: [24,12,8,6]\rApproach:\nLeft = [1,2,6,24]\rOutput[i] = Left[i-1] * Right multipication\rSo basically, we need to obtain a left multiplication array and store their right multiplication array in a variable.\nclass Solution { public: vector\u0026lt;int\u0026gt; productExceptSelf(vector\u0026lt;int\u0026gt;\u0026amp; nums) { vector\u0026lt;int\u0026gt; output; // To obtain a left multiplication array  int left_product = 1; for (int i = 0; i \u0026lt; nums.size(); i++) { left_product = left_product * nums[i]; output.insert(output.begin()+i, left_product); } int right_product = 1; // to store right multipication  for (int i = nums.size()-1; i \u0026gt; 0; i--) { output[i] = output[i-1] * right_product; right_product = right_product * nums[i]; } // Edge case condition  // output[0] = output[0-1]*right_product  output[0] = right_product; return output; } };   Time Complexity: O(n), where n is the number of elements.\n  Space complexity: O(1) since we are not using any extra data structure for computation.\nNOTE: The output array does not count as extra space for space complexity analysis.\n  Thanks for reading!\n","permalink":"https://ankitaS11.github.io/posts/2021/10/product-of-an-array-except-self/","tags":["coding","leetcode","notes","cpp"],"title":"Product of an array except self"},{"categories":["python"],"contents":"The itertools is a module in Python having a collection of functions for handling iterators. They make iterating through the iterables like lists and strings very easily.\nitertools.product() is a function in itertools module to generate cartesian product of multiple lists in python, it is equivalent to for loops. They basically creates iterators for efficient looping and falls under the category of combinatoric iterators .\nWhat does itertools.product() do ?\nitertools.product() is used to find the cartesian product multiple lists and can be used in two different ways -\n  itertools.product(*iterables) : To return the cartesian product of all the iterables provided as the argument. For example product(x1, x2, x3).\n  itertools.product(*iterables, repeat=1): To return the cartesian product of the provided iterable with itself for the number of times specified by the keyword repeat. For example : product(x, repeat =3) which is equivalent to product(x,x,x).\n  Example 1\nimport itertools import pprint l1 = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;] l2 = [\u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;f\u0026#39;] p = itertools.product(l1,l2) print(p) # \u0026lt;itertools.product.object at 0x1026edd80\u0026gt; print(type(p)) # \u0026lt;class \u0026#39;itertools.product\u0026#39;\u0026gt; itertools.product() returns an object of type itertools.product, which is an iterator, so the contents is not the output by print().\nExample 2\nYou can specify the number of iterations that can be used to generate a cartesian product using the keyword arguement repeat.\nl1 = [\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;] # pprint is used to make the results easier to read pprint.pprint(list(itertools.product(l1, repeat=3))) Output\n[('a', 'a', 'a'),\r('a', 'a', 'b'),\r('a', 'b', 'a'),\r('a', 'b', 'b'),\r('b', 'a', 'a'),\r('b', 'a', 'b'),\r('b', 'b', 'a'),\r('b', 'b', 'b')]\rComparison with Nested Loops\nYou know what? itertools.product() functions are significantly slower than for loops. Then why do we use it?\nIn many situations, you will often have to compare each item in a list to eaach other item in a list, creating well-known nested for loop.\nresult = [] for i in list_: for j in another_list_: result.append(func(i,j)) This is alright! But what when you have multiple lists as shown in the code below?\nresult = [] for i in list_: for j in another_list: for k in yet_another_list_: for l in hey_here_this_list_: result.append(func(i, j, k, l)) Using multiple for loops makes the code look ugly and complex. This is where itertools.product() comes into use coz sometimes code readability \u0026gt; performance.\nAlso, one of the reason to use itertools.product() is due to its memory efficiency as it returns a generator and generators are memory efficient (they use lazy evaluation). To know understand more about generators, visit my previous blog.\nThank you for reading :) !\n ","permalink":"https://ankitaS11.github.io/posts/2021/09/python-itertools.product/","tags":["coding","python","notes","itertools"],"title":" Python - itertools.product()"},{"categories":["python"],"contents":"The itertools is a module in Python having a collection of functions for handling iterators. They make iterating through the iterables like lists and strings very easily.\nitertools.chain() is a function in itertools module that takes a series of iterables and returns one iterable. It basically groups all the iterable together and produces a single iterable as output. They come under the category of terminating iterators.\nSyntax\nitertools.chain(*iterables) Example 1\nLets take an example to understand its functioning.\nfrom itertools import chain # list of odd numbers odd = [1, 3, 5, 7, 9] # list of even numbers even = [2, 4, 6, 8, 10] # chaining odd and even numbers  numbers = list(chain(odd,even)) print(numbers) Output\n[1 2 3 4 5 6 7 8 9 10]\rExample 2\nCombining two lists of alphabets and sorting them.\nfrom itertools import chain # some vowels vowels = [\u0026#39;a\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;i\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;u\u0026#39;] # some consonants consonants = [\u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;f\u0026#39;] # combined list combine = list(chain(consonants, vowels)) combine.sort() print(combine) Output\n['a', 'b', 'c', 'd', 'e', 'f', 'i', 'o', 'u']\rExample 3\nfrom itertools import chain res = list(chain(\u0026#39;ABC\u0026#39;, \u0026#39;DEF\u0026#39;, \u0026#39;GHI\u0026#39;, \u0026#39;JKL\u0026#39;)) print(res) Output\n['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L']\rExample 4\nNow consider the given list :  li =['123', '456', '789'] You are supposed to calculate the sum of the list taking every single digit into account. So the answer should be : 1+2+3+5+6+7+8+9 = 45 This can be achieved easily using the code below :\nfrom itertools import chain li = [\u0026#39;123\u0026#39;, \u0026#39;456\u0026#39;, \u0026#39;789\u0026#39;] res = list(map(int, list(chain.from_iterable(li)))) sum_of_li = sum(res) print(\u0026#34;res =\u0026#34;, res, end =\u0026#34;\\n\\n\u0026#34;) print(\u0026#34;sum =\u0026#34;, sum_of_li) Output\nres = [1, 2, 3, 4, 5, 6, 7, 8, 9]\rsum = 45\rOne more popular function from itertools module is itertools.product, which I will be discussing in the next blog.\nNOTE : These are just my notes, some of the texts can be similar to what you see in GFGs articles. I’ve tried not to be unnecessarily creative with my words.\n  ","permalink":"https://ankitaS11.github.io/posts/2021/09/python-itertools.chain/","tags":["coding","python","notes","itertools"],"title":"Python - itertools.chain()"},{"categories":["GANs"],"contents":"GANs are deep neural architecture trained in an adversarial manner (in english dictionary, adversarial means conflict or opposition) to generate data that mimics the distribution we want to approximate. It comprises of two networks - Generator and Discriminator, competing one against the other (that is why Adversarial).\n  Discriminator\nIt discriminates between two different classes of data, that is why known as binary classifier. For exampe when you want to classify real and fake images of person, then discriminative network comes into use. The output of these will be either 0 or 1 (0 - when it is fake and 1 - when its real). The role of discriminator is to discriminate between two different classes and produce the result as fake(0) or not fake(1).\n  Generator\nThe generator part of a GAN creates fake data by incorporating feedback from the discriminator. The portion of the GAN that trains the generator includes:\n Random input Generator network, which transforms the random input into a data instance Discriminator network, which classifies the generated data Discriminator output generator loss, which penalizes the generator for failing to fool the discriminator.    LOSS FUNCTION\nThe role of discriminator is to recognize an image as fake(image generated from generator) or real image accurately. It should produce 1 for real disributiom and 0 for generated distributions. While, generator generates images similar to the sample data distribution such that discriminator cannot distinguish it with the original data.\nOnce the generator produces correct classification, back propogation will be done as generator fails to fool the discriminator so its an error, this back-propogation will adjust the weights and biases of generator network. When the weights and biases gets adjusted, the generator will again generate samples from these distributions, this time making hard for the discriminator to classify real and generated distributions. This process goes on until the discriminator fails to classify between real and fake distributions.\nFirst of all, lets get familiar with the mathematical terms -\n Pdata(x): Probablity distribution of the sample dataset (our objective is to approximate this Pdata(x) through generator function) x: instantiation of random variable X.These x are fed into D(x,theta1) produces transformed variable represented as D(X). D(X) represents the probability that X is basically coming from the original dataset. D(X) have range between 0 and 1. pZ(z): Random distribution z: samples generated by random noise. z feded into generator which is a neural network takes input as z and parametrize by theta2, G(z, theta2) theta2 will represnt the weights and biases for the neural network represented by generator network which will be adjusted during the back propogation produces transformed variable represented as G(z).  NOTE: G and D are differentiable functions( once you are doing the back-propogation, it should be easily differentiable)\n pg(x): Probability distribution of dataset generated from generator. OBJECTIVE : pg(x) = pdata(x)  When G(z) is fed into the discriminator, it produces the probability represented as D(G(z)) which ranges between 0 and 1.\nA generative model G to be trained on training data X sampled from some true distribution D is the one which given some random distribution Z produces D' close to D according to some closeness metric. Mathematically z~Z maps to a sample G(z) ~ D'(Generative samples in D').\nBinary cross entropy loss function is given as - L(ypred, y) = y log(ypred) + (1-y) log(1-ypred) where, ypred = reconstructed image, y = original image\nThe labels for the data coming from original data distribution ie. pdata(x) is y=1 (real dataset) and the reconstructed labels ypred = D(X).\nL(D(X),1) = log(D(X))\nFor the data coming from generator the label is y=0 (fake dataset) and ypred = D(G(X)) so in that case\nL(D(G(z)),0) = log(1-D(G(z))\n D(x) = Discriminator activation applied directly to the actual input data. D(G(z)) = Discriminator activation applied to the generated data  Since the objective of the discriminator is to currently classify fake vs real dataset. For this reason eqn 1 and 2 must be maximized. (Can be visualized more by drawing graphs of these two eqns)\nD = max{log(D(x)+log(1-D(G(z)))} \nSince the objective of the generator is to fool the discriminator that means it wants D(G(z)) = 1. This means we need to minimize the objective function.\nG = min{log(D(x))+log(1-D(G(z)))}\nSo during the game between generator and discriminator, the target of D(Discriminator) is to maximize the above cost function while G(Generator) tries to minimize. By combining both these objectives, we can write the final equation as, This was all about the basics of GAN and its loss functions. I will discuss more about implementation of GANs in my next blog.\nThanks for reading!\n","permalink":"https://ankitaS11.github.io/posts/2021/09/basics-of-gans-and-loss-function/","tags":["GANs","notes","Deep Learning"],"title":"Basics of GANs and Loss Function"},{"categories":["python"],"contents":"Decorators are functions which modifies the functionality of other functions (instead of adding more codes to original function, decorators can be used). Decorators wrap around the main function and allow us to operate on inputs and outputs. Firstly let us understand functions in python -\ndef operations(x): \u0026#34;\u0026#34;\u0026#34;Incrementing x by 1\u0026#34;\u0026#34;\u0026#34; x += 1 return x operations(x=1) Now let\u0026rsquo;s say we want to increment our input x by 1 before and after the operations function executes and, to illustrate this example, here\u0026rsquo;s how we would do it by changing the original code:\ndef operations(x): \u0026#34;\u0026#34;\u0026#34;Basic operations.\u0026#34;\u0026#34;\u0026#34; x += 1 x += 1 x += 1 return x operations(x=1) Output\n4\rWe were able to achieve what we want but we now increased the size of our operations function and if we want to do the same incrementing for any other function, we have to add the same code to all of those as well which is not very efficient. This is where decorators comes in to use. Lets understand how to create a decorator -\nThe decorator function accepts a function f which is the function we wish to wrap around, ( in our case, it\u0026rsquo;s operations()). The output of the decorator is its wrapper function which receives the arguments and keyword arguments passed to function f.\nInside the wrapper function, we can :\n extract the input parameters passed to function f. make any changes we want to the function inputs. function f is executed make any changes to the function outputs wrapper function returns some value(s), which is what the decorator returns as well since it returns wrapper.  Decorator def add(f): def wrapper(*args, **kwargs): \u0026#34;\u0026#34;\u0026#34;Wrapper function for @add.\u0026#34;\u0026#34;\u0026#34; x = kwargs.pop(\u0026#34;x\u0026#34;) # .get() if not altering x x += 1 # executes before function f x = f(*args, **kwargs, x=x) x += 1 # executes after function f return x return wrapper We can use this decorator by simply adding it to the top of our main function preceded by the @ symbol.\n@add def operations(x): \u0026#34;\u0026#34;\u0026#34;Basic operations.\u0026#34;\u0026#34;\u0026#34; x += 1 return x operations(x=1) output\n4\rThe function name and docstring are not what we\u0026rsquo;re looking for but it appears this way because the wrapper function is what was executed. In order to fix this, Python offers functools.wraps which carries the main function\u0026rsquo;s metadata.\nfrom functools import wraps # Decorator def add(f): @wraps(f) def wrap(*args, **kwargs): \u0026#34;\u0026#34;\u0026#34;Wrapper function for @add.\u0026#34;\u0026#34;\u0026#34; x = kwargs.pop(\u0026#34;x\u0026#34;) x += 1 x = f(*args, **kwargs, x=x) x += 1 return x return wrap @add def operations(x): \u0026#34;\u0026#34;\u0026#34;Basic operations.\u0026#34;\u0026#34;\u0026#34; x += 1 return x Using decorators, we managed to decorate our main function operation() to achieve the customization we wanted without actually altering the function. We can reuse our decorator for other functions that may need the same customization!\n","permalink":"https://ankitaS11.github.io/posts/2021/09/python-decorators/","tags":["coding","python","notes"],"title":"Python Decorators"},{"categories":["python"],"contents":"Iteration refers to the process of repeating the same logic more than one time.\nAn iterator is an object containing a countable number of values and is used to iterate over iterable objects (list, tuples, dictionaries, sets, etc.). It implements the iterator protocol, which consists of the methods __ iter__() and __ next__().\niter() keyword is used to create an iterator containing an iterable object. next() keyword is used to call the next element in the iterable object.\nOnce the iterable object is completed, in order to use them again we reassign them to the same object. Example:\nmy_list = [1,2,3,4] iter_obj=iter(my_list) # Creates an interator print(type(iterable)) # prints list_iterator  # indicating this is an iterator print(next(iter_obj)) # prints the first element i.e 1 print(next(iter_obj)) # prints the next element i.e 2 print(next(iter_obj)) # prints the next element i.e 3 and so on. Here my_list is iterable and iter_obj is an iterator.\nNow, let\u0026rsquo;s see how to create an iterator.\nclass Multiples: def __iter__(self): self.a = 1 return self def __next__(self): if self.a \u0026lt;= 10: x = self.a self.a += 1 return x else: raise StopIteration # Creating an object of class Multiples  my_obj = Multiples() # Creating an iterator  my_iter = iter(my_obj) # Iterating through an iterator  for x in my_iter: print(x) Output\n1\r2\r3\r4\r5\r6\r7\r8\r9\r10\rIterator follows lazy evaluation where the evaluation of expression will be on hold and stored in the memory until the item is called which helps to avoid repeated evaluation. This is why it requires only one memory location to process the value.\nNow coming to generators. A python generator function lends us a sequence of values to python to iterate on. They are implemented using a function. Here, the yield function returns the data without affecting or exiting the function. They are efficient in writing fast and compact code, this is an advantage over Python iterators. They also follow lazy evaluation. Unlike iterator which do not uses local variables, the generator uses yield keyword to save the values of the local variable. A generator may have any number of \u0026lsquo;yield\u0026rsquo; statements.\ndef Even(max): number = 1 while number \u0026lt; max: number += 1 if (number%2 == 0): yield number # Iterating using generator function  for i in Even(10): print(i) The output is:-\n2\r4\r6\r8\r10\rGenerators and iterators both provides considerable performance boost when used over large size datasets owing to their ability to not generate and store the data all at once, rather they do it sequentially and on demand.\n","permalink":"https://ankitaS11.github.io/posts/2021/09/iterators-and-generators-in-python/","tags":["coding","python","notes"],"title":"Iterators and Generators in Python"},{"categories":["python"],"contents":"In class and objects, dunder str ( __ str __( ) ) and dunder repr ( __ repr __( ) ) built-in functions, also known as magic functions are used to return the string representation of the object. If both of them return strings, then what’s the difference between them?\nFirstly, let’s see what these functions returns when they are not defined in the class.\n# Creating a class named Addition class Addition: def __init__(self,num1,num2): self.num1 = num1 self.num2 = num2 def Add(self): add = self.num1+self.num2 return add # Creating an object of Addition class a = Addition(3,4) print(a.__str__) print(a.__repr__) Output\n\u0026lt;method-wrapper '__str__' of Addition object at 0x0000024EB29404A8\u0026gt;\r\u0026lt;method-wrapper '__repr__' of Addition object at 0x0000024EB29404A8\u0026gt;\rAs you can see, both simply tells us that it’s an instance object of the class Addition at the some memory address which is same for both the methods.\nNow, let\u0026rsquo;s define __ str __ ( ) in our class.\nclass Addition: def __init__(self,num1,num2): self.num1 = num1 self.num2 = num2 def __str__(self): add = self.num1+self.num2 return str(add) def Add(self): add = self.num1+self.num2 return add # Creating an object of Addition class a = Addition(3,4) print(a) # dunder str will be called a # this will return an address Output\n7\r\u0026lt;__main__.Addition at 0x24eb2940da0\u0026gt;\rThe __ str __( ) method will be called when print( ) is invoked while on calling the object a it simply returns the address. Interesting right? Now, let\u0026rsquo;s remove the __ str __( ) method and define __ repr __( ) in the class and see the results.\nclass Addition: def __init__(self,num1,num2): self.num1 = num1 self.num2 = num2 def __repr__(self): add = self.num1+self.num2 return str(add) def Add(self): add = self.num1+self.num2 return add # Creating an object of Addition class a = Addition(3,4) print(a) # dunder repr will be called a # dunder repr will be called Output\n7\r7\rBasically, what happens is when str is not defined, then it will call repr. The repr returns a string that by default describes the pointer of the object.\nLet\u0026rsquo;s see what happens when both the methods are defined in the class?\nclass Calci: def __init__(self,num1,num2): self.num1 = num1 self.num2 = num2 def __repr__(self): add = self.num1+self.num2 return str(self.num1) def __str__(self): add = self.num1+self.num2 return str(add) def Add(self): add = self.num1+self.num2 return add c = Calci(3,4) # Creating an object c of class Calci print(c) # this will call __str__() print([c]) # this will call __repr__() c # this will also call __repr__() Output\n7\r[3]\r3\rWhen print(c) is invoked __ str __( ) was called, when print([c]) is invoked __ repr __( ) was called, whereas when we just inspected the object c, __ repr __( ) was called.\nBoth str and repr functuions are used to return the string representation of the object. When we just inspect the object, __ repr__( ) will be called while __ str __( ) is called when print( ) is invoked. When __ str __( ) is not defined, then it will call __ repr __( ) . The __ repr __( ) returns a string that by default describes the pointer of the object. Moreover, __ str __( ) should always return a string, whereas the __ repr __( ) can return any valid Python expression.\nCONCLUSION\n__ str __ ( ) is used for creating output that is mainly for end-users to show the descriptive information of the object from an end user’s perspective in terms of what data the object contains. Whereas __ repr __( ) shows the unambiguous information of the object from a developer’s perspective in terms of how the object can be constructed.\n ","permalink":"https://ankitaS11.github.io/posts/2021/09/understanding-__-str-__-and-__-repr-__-in-python/","tags":["coding","python","notes"],"title":"Understanding __ str __( ) and  __ repr __( ) in Python"},{"categories":["cpp"],"contents":"Vectors are sequence container class that stores its elements in contiguous memory locations and implements dynamic array, which means it allocates memory at run time and resizes itself automatically when an element is inserted or deleted. Vectors can simply be thought of as an array that has the ability to automatically resize itself.\nWe need to import the header \u0026lt;vector\u0026gt; to make use of vectors.#include \u0026lt;vector\u0026gt;\nVECTOR DECLARATION AND INITIALISATION\nThe syntax to declare the array is given below :\nstd::vector \u0026lt;data_type\u0026gt; vector_name; Example\n#include \u0026lt;iostream\u0026gt;#include \u0026lt;vector\u0026gt;using namespace std; int main() { // Declaring a vector v  // having 0 elements  vector \u0026lt;int\u0026gt; v; // Declaring a vector v1  // and assigning values.  vector \u0026lt;int\u0026gt; v1 = {1,2,3,4,5} return 0; } COPYING A VECTOR\nMethod 1:\nv2 = v1; // vector v2 is the copy of vector v1. Method 2:\nstd::vector\u0026lt;int\u0026gt; v3; // Declaring vector v3 auto v3(v1) // copying vector v1 to v3. ACCESSING DATA\nstd::vector has the following functions to access the underlying data.\n front(): To access the first element of the vector. back(): To access the last element of the vector. at(): To access specific elements. (It provides bound check: If the element you are trying to access is out-of-bounds, at() throws an exception.) []: To access specific elements.( without bound check: [] operator will not provide any bounds checking, providing for faster access while increasing the risk of a segmentation fault.)  v1.front() // for accessing first element of vector v1.back() // for accessing last element of vector v1[0] // for accessing element at oth index. v1.at(4) // for accessing element at 4th index. data() : The function returns a pointer to the first element which is used internally by the vector.  #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; int main() { // initialising vector  vector \u0026lt;int\u0026gt; v = { 1, 2, 3, 4, 5 }; // memory pointer pointing to the  // first element  int* pos = v.data(); // prints the vector  for (int i = 0; i \u0026lt; v.size(); i++) cout \u0026lt;\u0026lt; *pos++ \u0026lt;\u0026lt; \u0026#34; \u0026#34;; return 0; } ADDING AND REMOVING ELEMENTS\nstd::vector has a variety of functions to add or remove elements from the vector.\n push_back(): The function adds an element at the end of the vector and increases the size by 1. emplace_back(): emplace_back() allows for constructor arguments to be forwarded so that the new element can be constructed in place. pop_back(): The function deletes the last element present in the vector and reduces the size by 1. insert(): To insert elements at specific element. Supply an iterator to the location where the new element should be inserted: erase(): To erase a specific element, call the erase() function and supply an iterator to the element you want to remove.  int x = 0; v2.push_back(x); // adds element to end v2.pop_back(x); // deletes last element v2.insert(v2.begin(),x); // adds element in beg(v2.begin()). v2.emplace_back(10); // constructs an element in place at the end v2.erase(v2.begin()); // wil erase the first element MANAGING MEMORY\nExtra memory can be allocated to prevent a std::vector to reallocate memory every time a new element is inserted. Additionally, if you remove elements from the std::vector, that memory remains allocated to the std::vector.\nLuckily, the std::vector class provides us a few functions for managing memory.\n reserve(): Often, you are aware of how many elements you need to store in your std::vector (at least as a maximum). As reallocations are costly in terms of performance, you can use the reserve() function to make a single large allocation, reducing the runtime hit that may occur from frequent reallocations. NOTE: reserve() can only increase the vector size. If the requested capacity is smaller than the current capacity, nothing happens. shrink_to_fit() : shrink_to_fit() performs a memory allocation to achieve the reduced size. If you have reserved space greater than your current needs, you can shrink the buffer. clear(): The clear() function erases all elements in the vector without reducing the capacity. resize(): function to manually increase or decrease the size of your std::vector at will. If you are increasing the size using resize(), the new elements will be 0-initialized by default. You can also supply an initialization value for the new elements. If you are resizing to a smaller size, the elements at the end of the list will be removed.  v2.reserve(10) // increase vector capacity to 10 elements v2.shrink_to_fit(); // shrinks the buffer. v2.clear() // erases all elements v2.resize(5); // resize to 5. The new elements will be 0-initialized v2.resize(10, -1); // resize to 10. New elements initialized with -1 v2.resize(4); // shrink and strip off extra elements NOTE: If you want to add space but don’t want to add elements to the vector, use the reserve() function instead of resize().\nOTHER USEFUL INTERFACES\n size() : returns number of elements present. capacity(): returns the current amount of memory allocated for the vector in terms of the number of elements.  NOTE: size() returns the number of present elements, capacity() is the current upper limit on the number of memory blocks allocated.You can clear all elements in a std::vector by using the clear() function. This will set the size() to 0, but note that capacity() will remain at the previous allocation level.\nempty(): To check whether the vector is empty. 0-\u0026gt; true false otherwise. max_size(): This returns maximum size of a std::vector on the system.  FOR LOOP\n// Method 1  for(int j = 0; j \u0026lt; v2.size(); j++) // Method 2  for(auto \u0026amp;t: v2) Example:\nstd::cout \u0026lt;\u0026lt; std::endl \u0026lt;\u0026lt; \u0026#34;v2: \u0026#34; \u0026lt;\u0026lt; std::endl; for (const auto \u0026amp; t : v2) { std::cout \u0026lt;\u0026lt; t \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } std::cout \u0026lt;\u0026lt; std::endl; SORT OPERATION\nstd::sort(v2.begin(), v2.end()); TIME COMPLEXITY\n Random access – O(1) Insertion or removal of elements at the end – O(1) Insertion or removal of elements – O(n)   ","permalink":"https://ankitaS11.github.io/posts/2021/09/vectors-in-c-/","tags":["coding","cpp","notes","vectors"],"title":"Vectors in C++"},{"categories":null,"contents":"Hello! I am a third-year Electronics and Communication Engineering undergraduate at International Institute of Information Technology, Naya Raipur, Chhattisgarh, India.\nWork Experience   Summer Research Intern - Indian Institute of Technology, Bhilai (May 2021 - Aug 2021).\n Mentor: Dr. Gagan Raj Gupta, Visiting Associate Professor, IIT Bhilai Scraped websites and collected landslide descriptions from the year 2006-2020, prepared dataset, extracted information from descriptions using NER(Named Entity Recognition), and performed data preprocessing. Analyzed and visualized data using matplotlib, folium, and seaborn. Designed and managed GIS database from scratch using MongoDB and automated new entries in the database. Clustered similar landslide events on the basis of geo-location using DBSCAN Clustering. Twitter Bot that reports recently occurred landslides as well as predicts the landslide events. TechStack - Python, Numpy, Pandas, Matplotlib, GeoPy, NLP, MongoDB    Technical Content Writer - Learn Electronics (Dec 2020 - Jan 2021)\n  Technical Skills  Programming Languages: Python, C, C++, R Tools: Anaconda, MATLAB, LaTeX, Git Libraries: Pandas, NumPy, MatPlotlib, scikit-learn, openCV  Contact me You can connect with me on Linkedin or email at anki4586@gmail.com\n","permalink":"https://ankitaS11.github.io/about/","tags":null,"title":"About"},{"categories":null,"contents":"https://www.ncbi.nlm.nih.gov/pmc/articles/PMC7600474/\n","permalink":"https://ankitaS11.github.io/posts/1/01/","tags":null,"title":""},{"categories":null,"contents":"Improved vision has lots of real life applications including the cameras used in self driving cars, medical images to diagnose accurately. I am currently working on a project named \u0026quot; Vechicle Detection in Foggy/Rainy season\u0026quot; to help improve the performance of self driving cars in adverse weather. For that I used some basic image processing techniques to start with and improve the visibility of vechicle images in foggy weather. Improved vision will not only help to prevent accidents in self-driving cars but also it can be used with traffic light systems, to detect vehicles and their license numbers/color of vehicle/model with better accuracy. This will be just a basic idea to improve the images. Lets look into the sample image -\nImage What if I increase the contrast of the images without affecting its color components? This is just an intution let\u0026rsquo;s try and see what happens!\nWe were quite successful in improving the visibility of images.\n","permalink":"https://ankitaS11.github.io/posts/1/01/","tags":null,"title":""},{"categories":null,"contents":"","permalink":"https://ankitaS11.github.io/categories/","tags":null,"title":"Categories"}]