[{"categories":["python"],"contents":"Decorators are functions which modifies the functionality of other functions (Instead of adding more codes to original function, decorators can be used). Decorators wrap around the main function and allow us to operate on inputs and outputs. Firstly let us understand functions in python -\ndef operations(x): \u0026#34;\u0026#34;\u0026#34;Incrementing x by 1\u0026#34;\u0026#34;\u0026#34; x += 1 return x operations(x=1) Now let\u0026rsquo;s say we want to increment our input x by 1 before and after the operations function executes and, to illustrate this example, let\u0026rsquo;s say the increments have to be separate steps. Here\u0026rsquo;s how we would do it by changing the original code:\ndef operations(x): \u0026#34;\u0026#34;\u0026#34;Basic operations.\u0026#34;\u0026#34;\u0026#34; x += 1 x += 1 x += 1 return x operations(x=1) Output\n4\rWe were able to achieve what we want but we now increased the size of our operations function and if we want to do the same incrementing for any other function, we have to add the same code to all of those as well which is not very efficient. This is where decorators are used called add which increments x by 1 before and after the main function f executes.\nCreating a decorator The decorator function accepts a function f which is the function we wish to wrap around, in our case, it\u0026rsquo;s operations(). The output of the decorator is its wrapper function which receives the arguments and keyword arguments passed to function f.\nInside the wrapper function, we can: 1. extract the input parameters passed to function f. 2. make any changes we want to the function inputs. 3. function f is executed 4. make any changes to the function outputs 5. wrapper function returns some value(s), which is what the decorator returns as well since it returns wrapper.\nDecorator def add(f): def wrapper(*args, **kwargs): \u0026#34;\u0026#34;\u0026#34;Wrapper function for @add.\u0026#34;\u0026#34;\u0026#34; x = kwargs.pop(\u0026#34;x\u0026#34;) # .get() if not altering x x += 1 # executes before function f x = f(*args, **kwargs, x=x) x += 1 # executes after function f return x return wrapper We can use this decorator by simply adding it to the top of our main function preceded by the @ symbol.\n@add def operations(x): \u0026#34;\u0026#34;\u0026#34;Basic operations.\u0026#34;\u0026#34;\u0026#34; x += 1 return x operations(x=1) output\n4\rThe function name and docstring are not what we\u0026rsquo;re looking for but it appears this way because the wrapper function is what was executed. In order to fix this, Python offers functools.wraps which carries the main function\u0026rsquo;s metadata.\nfrom functools import wraps # Decorator def add(f): @wraps(f) def wrap(*args, **kwargs): \u0026#34;\u0026#34;\u0026#34;Wrapper function for @add.\u0026#34;\u0026#34;\u0026#34; x = kwargs.pop(\u0026#34;x\u0026#34;) x += 1 x = f(*args, **kwargs, x=x) x += 1 return x return wrap @add def operations(x): \u0026#34;\u0026#34;\u0026#34;Basic operations.\u0026#34;\u0026#34;\u0026#34; x += 1 return x Using decorators, we managed to decorate our main function operation() to achieve the customization we wanted without actually altering the function. We can reuse our decorator for other functions that may need the same customization!\n","permalink":"https://ankitaS11.github.io/posts/2021/09/understanding-decorators-in-python/","tags":["coding","python","notes"],"title":"Understanding Decorators in Python"},{"categories":["python"],"contents":"Iteration refers to the process of repeating the same logic more than one time.\nAn iterator is an object containing a countable number of values and is used to iterate over iterable objects (list, tuples, dictionaries, sets, etc.). It implements the iterator protocol, which consists of the methods __ iter__() and __ next__().\niter() keyword is used to create an iterator containing an iterable object. next() keyword is used to call the next element in the iterable object.\nOnce the iterable object is completed, in order to use them again we reassign them to the same object. Example:\nmy_list = [1,2,3,4] iter_obj=iter(my_list) # Creates an interator print(type(iterable)) # prints list_iterator  # indicating this is an iterator print(next(iter_obj)) # prints the first element i.e 1 print(next(iter_obj)) # prints the next element i.e 2 print(next(iter_obj)) # prints the next element i.e 3 and so on. Here my_list is iterable and iter_obj is an iterator.\nNow, let\u0026rsquo;s see how to create an iterator.\nclass Multiples: def __iter__(self): self.a = 2 return selfdef __next__(self): if self.a \u0026lt;= 10: x = self.a self.a += 1 return x else: raise StopIteration my_obj = Multiples() my_iter = iter(myclass) for x in myiter: print(x) Output\n1\r2\r3\r4\r5\r6\r7\r8\r9\r10\rIterator follows lazy evaluation where the evaluation of expression will be on hold and stored in the memory until the item is called which helps to avoid repeated evaluation. This is why it requires only one memory location to process the value.\nNow coming to generators. A python generator function lends us a sequence of values to python to iterate on. They are implemented using a function. Here, the yield function returns the data without affecting or exiting the function. They also follow lazy evaluation. Unlike iterator which do not uses local variables, the generator uses yield keyword to save the values of the local variable. A generator may have any number of \u0026lsquo;yield\u0026rsquo; statements.\ndef even(x): while(x!=0): if x%2==0: yield x x-=1 for i in even(8): print(i) The output is:-\n8\r6\r4\r2\rA generator is efficient for writing fast and compact code. This is an advantage over Python iterators.\n","permalink":"https://ankitaS11.github.io/posts/2021/09/understanding-iterators-and-generators-in-python/","tags":["coding","python","notes"],"title":"Understanding Iterators and Generators in Python"},{"categories":["python"],"contents":"In class and objects, dunder str ( __ str __( ) ) and dunder repr ( __ repr __( ) ) built-in functions, also known as magic functions are used to return the string representation of the object. If both of them return strings, then what’s the difference between them?\nFirstly, let’s see what these functions returns when they are not defined in the class.\n# Creating a class named Addition class Addition: def __init__(self,num1,num2): self.num1 = num1 self.num2 = num2 def Add(self): add = self.num1+self.num2 return add # Creating an object of Addition class a = Addition(3,4) print(a.__str__) print(a.__repr__) Output\n\u0026lt;method-wrapper '__str__' of Addition object at 0x0000024EB29404A8\u0026gt;\r\u0026lt;method-wrapper '__repr__' of Addition object at 0x0000024EB29404A8\u0026gt;\rAs you can see, both simply tells us that it’s an instance object of the class Addition at the some memory address which is same for both the methods.\nNow, let\u0026rsquo;s define __ str __ ( ) in our class.\nclass Addition: def __init__(self,num1,num2): self.num1 = num1 self.num2 = num2 def __str__(self): add = self.num1+self.num2 return str(add) def Add(self): add = self.num1+self.num2 return add # Creating an object of Addition class a = Addition(3,4) print(a) # dunder str will be called a # this will return an address Output\n7\r\u0026lt;__main__.Addition at 0x24eb2940da0\u0026gt;\rThe __ str __( ) method will be called when print( ) is invoked while on calling the object a it simply returns the address. Interesting right? Now, let\u0026rsquo;s remove the __ str __( ) method and define __ repr __( ) in the class and see the results.\nclass Addition: def __init__(self,num1,num2): self.num1 = num1 self.num2 = num2 def __repr__(self): add = self.num1+self.num2 return str(add) def Add(self): add = self.num1+self.num2 return add # Creating an object of Addition class a = Addition(3,4) print(a) # dunder repr will be called a # dunder repr will be called Output\n7\r7\rBasically, what happens is when str is not defined, then it will call repr. The repr returns a string that by default describes the pointer of the object.\nLet\u0026rsquo;s see what happens when both the methods are defined in the class?\nclass Calci: def __init__(self,num1,num2): self.num1 = num1 self.num2 = num2 def __repr__(self): add = self.num1+self.num2 return str(self.num1) def __str__(self): add = self.num1+self.num2 return str(add) def Add(self): add = self.num1+self.num2 return add c = Calci(3,4) # Creating an object c of class Calci print(c) # this will call __str__() print([c]) # this will call __repr__() c # this will also call __repr__() Output\n7\r[3]\r3\rWhen print(c) is invoked __ str __( ) was called, when print([c]) is invoked __ repr __( ) was called, whereas when we just inspected the object c, __ repr __( ) was called.\nBoth str and repr functuions are used to return the string representation of the object. When we just inspect the object, __ repr__( ) will be called while __ str __( ) is called when print( ) is invoked. When __ str __( ) is not defined, then it will call __ repr __( ) . The __ repr __( ) returns a string that by default describes the pointer of the object. Moreover, __ str __( ) should always return a string, whereas the __ repr __( ) can return any valid Python expression.\nCONCLUSION\n__ str __ ( ) is used for creating output that is mainly for end-users to show the descriptive information of the object from an end user’s perspective in terms of what data the object contains. Whereas __ repr __( ) shows the unambiguous information of the object from a developer’s perspective in terms of how the object can be constructed.\n ","permalink":"https://ankitaS11.github.io/posts/2021/09/understanding-__-str-__-and-__-repr-__-in-python/","tags":["coding","python","notes","str()","repr()"],"title":"Understanding __ str __( ) and  __ repr __( ) in Python"},{"categories":["cpp"],"contents":"Vectors are sequence container class that stores its elements in contiguous memory locations and implements dynamic array, which means it allocates memory at run time and resizes itself automatically when an element is inserted or deleted. Vectors can simply be thought of as an array that has the ability to automatically resize itself.\nWe need to import the header \u0026lt;vector\u0026gt; to make use of vectors.#include \u0026lt;vector\u0026gt;\nVECTOR DECLARATION AND INITIALISATION\nThe syntax to declare the array is given below :\nstd::vector \u0026lt;data_type\u0026gt; vector_name; Example\n#include \u0026lt;iostream\u0026gt;#include \u0026lt;vector\u0026gt;using namespace std; int main() { // Declaring a vector v  // having 0 elements  vector \u0026lt;int\u0026gt; v; // Declaring a vector v1  // and assigning values.  vector \u0026lt;int\u0026gt; v1 = {1,2,3,4,5} return 0; } COPYING A VECTOR\nMethod 1:\nv2 = v1; // vector v2 is the copy of vector v1. Method 2:\nstd::vector\u0026lt;int\u0026gt; v3; // Declaring vector v3 auto v3(v1) // copying vector v1 to v3. ACCESSING DATA\nstd::vector has the following functions to access the underlying data.\n front(): To access the first element of the vector. back(): To access the last element of the vector. at(): To access specific elements. (It provides bound check: If the element you are trying to access is out-of-bounds, at() throws an exception.) []: To access specific elements.( without bound check: [] operator will not provide any bounds checking, providing for faster access while increasing the risk of a segmentation fault.)  v1.front() // for accessing first element of vector v1.back() // for accessing last element of vector v1[0] // for accessing element at oth index. v1.at(4) // for accessing element at 4th index. data() : The function returns a pointer to the first element which is used internally by the vector.  #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; int main() { // initialising vector  vector \u0026lt;int\u0026gt; v = { 1, 2, 3, 4, 5 }; // memory pointer pointing to the  // first element  int* pos = v.data(); // prints the vector  for (int i = 0; i \u0026lt; v.size(); i++) cout \u0026lt;\u0026lt; *pos++ \u0026lt;\u0026lt; \u0026#34; \u0026#34;; return 0; } ADDING AND REMOVING ELEMENTS\nstd::vector has a variety of functions to add or remove elements from the vector.\n push_back(): The function adds an element at the end of the vector and increases the size by 1. emplace_back(): emplace_back() allows for constructor arguments to be forwarded so that the new element can be constructed in place. pop_back(): The function deletes the last element present in the vector and reduces the size by 1. insert(): To insert elements at specific element. Supply an iterator to the location where the new element should be inserted: erase(): To erase a specific element, call the erase() function and supply an iterator to the element you want to remove.  int x = 0; v2.push_back(x); // adds element to end v2.pop_back(x); // deletes last element v2.insert(v2.begin(),x); // adds element in beg(v2.begin()). v2.emplace_back(10); // constructs an element in place at the end v2.erase(v2.begin()); // wil erase the first element MANAGING MEMORY\nExtra memory can be allocated to prevent a std::vector to reallocate memory every time a new element is inserted. Additionally, if you remove elements from the std::vector, that memory remains allocated to the std::vector.\nLuckily, the std::vector class provides us a few functions for managing memory.\n reserve(): Often, you are aware of how many elements you need to store in your std::vector (at least as a maximum). As reallocations are costly in terms of performance, you can use the reserve() function to make a single large allocation, reducing the runtime hit that may occur from frequent reallocations. NOTE: reserve() can only increase the vector size. If the requested capacity is smaller than the current capacity, nothing happens. shrink_to_fit() : shrink_to_fit() performs a memory allocation to achieve the reduced size. If you have reserved space greater than your current needs, you can shrink the buffer. clear(): The clear() function erases all elements in the vector without reducing the capacity. resize(): function to manually increase or decrease the size of your std::vector at will. If you are increasing the size using resize(), the new elements will be 0-initialized by default. You can also supply an initialization value for the new elements. If you are resizing to a smaller size, the elements at the end of the list will be removed.  v2.reserve(10) // increase vector capacity to 10 elements v2.shrink_to_fit(); // shrinks the buffer. v2.clear() // erases all elements v2.resize(5); // resize to 5. The new elements will be 0-initialized v2.resize(10, -1); // resize to 10. New elements initialized with -1 v2.resize(4); // shrink and strip off extra elements NOTE: If you want to add space but don’t want to add elements to the vector, use the reserve() function instead of resize().\nOTHER USEFUL INTERFACES\n size() : returns number of elements present. capacity(): returns the current amount of memory allocated for the vector in terms of the number of elements.  NOTE: size() returns the number of present elements, capacity() is the current upper limit on the number of memory blocks allocated.You can clear all elements in a std::vector by using the clear() function. This will set the size() to 0, but note that capacity() will remain at the previous allocation level.\nempty(): To check whether the vector is empty. 0-\u0026gt; true false otherwise. max_size(): This returns maximum size of a std::vector on the system.  FOR LOOP\n// Method 1  for(int j = 0; j \u0026lt; v2.size(); j++) // Method 2  for(auto \u0026amp;t: v2) Example:\nstd::cout \u0026lt;\u0026lt; std::endl \u0026lt;\u0026lt; \u0026#34;v2: \u0026#34; \u0026lt;\u0026lt; std::endl; for (const auto \u0026amp; t : v2) { std::cout \u0026lt;\u0026lt; t \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } std::cout \u0026lt;\u0026lt; std::endl; SORT OPERATION\nstd::sort(v2.begin(), v2.end()); TIME COMPLEXITY\n Random access – O(1) Insertion or removal of elements at the end – O(1) Insertion or removal of elements – O(n)   ","permalink":"https://ankitaS11.github.io/posts/2021/09/vectors-in-c-/","tags":["coding","cpp","notes","vectors"],"title":"Vectors in C++"},{"categories":null,"contents":"Hello! I am a third-year Electronics and Communication Engineering undergraduate at International Institute of Information Technology, Naya Raipur, Chhattisgarh, India.\nWork Experience   Summer Research Intern - Indian Institute of Technology, Bhilai (May 2021 - Aug 2021).\n Mentor: Dr. Gagan Raj Gupta, Visiting Associate Professor, IIT Bhilai Scraped websites and collected landslide descriptions from the year 2006-2020, prepared dataset, extracted information from descriptions using NER(Named Entity Recognition), and performed data preprocessing. Analyzed and visualized data using matplotlib, folium, and seaborn. Designed and managed GIS database from scratch using MongoDB and automated new entries in the database. Clustered similar landslide events on the basis of geo-location using DBSCAN Clustering. Twitter Bot that reports recently occurred landslides as well as predicts the landslide events. TechStack - Python, Numpy, Pandas, Matplotlib, GeoPy, NLP, MongoDB    Technical Content Writer - Learn Electronics (Dec 2020 - Jan 2021)\n  Technical Skills  Programming Languages: Python, C, C++, R Tools: Anaconda, MATLAB, LaTeX, Git Libraries: Pandas, NumPy, MatPlotlib, scikit-learn, openCV  Contact me You can connect with me on Linkedin or email at anki4586@gmail.com\n","permalink":"https://ankitaS11.github.io/about/","tags":null,"title":"About"},{"categories":null,"contents":"","permalink":"https://ankitaS11.github.io/categories/","tags":null,"title":"Categories"}]